---
title: "DispersionCalculator v0.6"
output: html_document
---

This document explains DispersionCalculator's method for estimating dispersion coefficients.

### Input files

The calculator requires three input files:

##### Dxdy input
Each row in this file corresponds to a cell in the two dimensional XY grid of the water body. The first two columns contain the integer pairs that index the 2D cells and the other two columns contain the cell dimensions.

##### Dye input
This file contains the concentrations for each cell in the three dimensional grid space of the water body at every timestep. The timestep blocks are delimited by single column rows that specify the timestep in julian days. Each row within a timestep block defines the concentrations along the Z direction for a cell in the two dimensional XY grid. The order of the rows matches the order of the rows in the Dxdy input file. In the three dimensional grid, the space above an XY cell divides into 5 cells, so for each row, there are five columns.

##### Depth input
This file indicates the water level above each XY cell and follows the same format as as the Dye input file. The first column of a timestep block indicates the water level and the second column indicates the adjustment factor.

### Preparing the data

After loading the input files, **DispersionCalculator** reformats the data into an axis-neutral format so that we can call a single, generalized function (`getAxisSecondMoments`) on the data to compute the centralized second moments at each timestep along any of the three axes.

The three axis-netural datasets that pass to `getAxisSecondMoments` are `delta.list.raw`, `dye.list.raw`, and `coor.list.raw`. Each element in these lists represents the data for one timestep. A timestep element in `delta.list.raw` is a table with six columns: x, y, z, dx, dy, dz. Each row represents one cell in the three dimensional grid. The x and y values are the XY grid indexes from the Dxdy input file and the Z cells are indexed one through five. A timestep in `dye.list.raw` has four columns: x, y, z, and dye. The x, y, and z columns contain the indexes and the dye column contains the dye concentrations. `coor.list.raw` has six columns: x, y, z, xcoor, ycoor, zcoor. The xcoor, ycoor, and zcoor are the representative coordinates in meters for each three dimensional grid cell. The program calculates the XY coordinates from the delta XY data after selecting one of the cells to be the origin. It calculates the Z coordinates above each XY cell by dividing its depth data by five.

After subsetting for the desired time frame, `getAxisSecondMoments` takes these "raw" datasets and the name of the axis for which it should calculate the average centralized second moments. It then pivots the timestep elements in each of these lists so that the first two columns contain the index coordinates of the other two axes, and the remaining columns correspond to each unique index value in the desired axis. For instance, if z were the axis along which `getAxisSecondMoments` is to compute the average second moments, it will reformat each timestep element in `dye.list.raw` so that it has columns x, y, 1, 2, 3, 4, and 5, since the Z axis has 5 indexes. If the desired axis were x, then it would be reformatted so that the columns are y, z, n, ..., m, where n and m are the lowest and highest indexes on the X axis, respectively. Finally, the function will then collapse these lists of reformatted data into three three-dimensional arrays.

For the remainder of this document, we'll use Z as the example axis for which we are calculating the average centralized second moments, but the formulas and code presented generalize to the other axes by simply swapping the variable names.

### Calculating the dye mass inventory

The goal is to calculate the total dye mass in all grid cells at every timestep.
Assumptions are that the dye concentrations in `dye.list.raw` are in g/m^3 and that dx, dy, and dz from `delta.list.raw` are in meters.  First the volume in each cell is calculated by multipling dx, dy and dz.  Next the dye mass is calculated for each cell by multiplying the cell volume by the cell dye concentration.  Finally the dye mass is summed for all cells at each timestep.

### Estimating dispersion rates

Because the following calculations require us to estimate areas under the coordinate curves, it's necessary to convert the coordinate values of the desired axis to their absolute values. In the case of the Z axis, this isn't necessary, since all of the Z coordinates are positive. But for the X and Y directions, we define an arbitrary origin for the X and Y coordinates, and there will be negative values.

Let $\mathcal{X}$, $\mathcal{Y}$, and $\mathcal{Z}$ be the sets of grid cell indexes. We first estimate the areas under the concentrations curve in the direction of the desired axis using Riemann sums. (This estimate could be improved in the future by using more sophisticated numerical integration techniques). 

$$
C_{ij}(t) = \sum_{k \in \mathcal{Z}} c_{ijk}(t) \delta z_{ijk}(t)
$$ 

where

* $c_{ijk}(t)$ is the concentration for the grid cell indexed by $(i,j,k)$ at timestep $t$

* $\delta z_{ijk}(t)$ is z-dimension for the cell indexed by $(i,j,k)$ at timestep $t$

* $C_{ij}(t)$ is the estimated integral of $c_{ijk}(t)$ along the Z direction


In R, we perform this calculation simultaneously for all timesteps using the following array operations:

```
cz.dz <- cz * dz
int.cz.dz <- apply(cz.dz, c(1,3), sum, na.rm=TRUE)

```

Where 

* `cz` is a 3D array of concentrations. The rows correspond to the XY index pairs, the columns correspond to the cells along the Z direction, and the slices correspond to the timesteps.

* `dz` is a 3D array of z-direction dimensions with the same structure as `cz`

Next we estimate the first moments of the concentration curves along the desired axis using the formula: 

$$
z^{\prime}_{ij}(t) = \frac{\sum_{k \in \mathcal{Z}} z_{ijk}(t) c_{ijk}(t) \delta z_{ijk}(t)}{C_{ij}(t)}
$$

where 

* $z_{ijk}(t)$ is the representative coordinate at timestep $t$ for the grid cell indexed by $(i,j,k)$

* $z^{\prime}_{ij}(t)$ is the first concentration moment at time $t$ above the grid cell indexed in the XY-plane by $(i,j)$


Again, we accomplish this in R using array operations:

```
z.cz.dz <- z * cz.dz
int.z.cz.dz <- apply(z.cz.dz, c(1,3), sum, na.rm=TRUE)
moment1 <- int.z.cz.dz / int.cz.dz

```

Now we can estimate the centralized second moment using the formula

$$
z^{\prime\prime}_{ij}(t) = \frac{\sum_{k \in \mathcal{Z}} z_{ijk}^2(t) c_{ijk}(t) \delta z_{ijk}(t)}{C_{ij}(t)} - z^{\prime 2}_{ij}(t)
$$

Which in R we accomplish with

```
z2.cz.dz <- z^2 * cz.dz
int.z.cz.dz <- apply(z.cz.dz, c(1,3), sum, na.rm=TRUE)
moment2 <- int.z2.cz.dz / int.cz.dz - moment1^2
```

Next, we calculate the concentration-weighted average centralized second moments at each timestep over the plane formed by the other two axes.

$$
z^{\prime\prime}_{mean}(t) = \frac{\sum_{i \in \mathcal{X}} \sum_{j \in \mathcal{Y}} z^{\prime\prime}_{ij}(t) C_{ij}(t) \overline{\delta_{ij}}(t)}{\sum_{i \in \mathcal{X}} \sum_{j \in \mathcal{Y}} C_{ij}(t) \overline{\delta_{ij}}(t)}
$$


where

$$
\overline{\delta_{ij}}(t) = \frac{\sum_{k \in \mathcal{Z}} x_{ijk}(t) y_{ijk}(t)}{|\mathcal{Z}_{ij}|}
$$

and $\mathcal{Z}_{ij}$ is the set of indexes $k \in \mathcal{Z}$  such that there exists a grid cell indexed by $(i, j, k)$.

Here, $\overline{\delta_{ij}}(t)$ is simply equal to $\delta x_{ij} \cdot \delta y_{ij}$, because for a given $(i, j)$, the area of the grid cell indexed by $(i,j,k)$ is not dependent on $k$. However, this simplification does not hold when we peform the calculation with respect to the x or y direction, because the water level varies with $i$ and $j$, and hence so do the z dimensions of the grid cells.  Therefore, it's necessary to use $\overline{\delta_{jk}}(t)$ and $\overline{\delta_{ik}}(t)$ to average the grid cell areas for these axes. Below is a figure illustrationg this complication for a simplified example with only two axes.

```{r fig, echo=FALSE, fig.width=5, fig.height=5, fig.align='center'}

library(RColorBrewer)
library(grid)

grid.newpage()
root.layout <- grid.layout(nrow=2, ncol=2, widths=unit(c(.2, .8), 'npc'), heights=unit(c(.2, .8), 'npc'))
pushViewport(viewport(height=.6, width=.95, layout=root.layout, name='root'))

n.grid.cols <- 6
pushViewport(viewport(layout=grid.layout(ncol=n.grid.cols, nrow=1), layout.pos.row=2, layout.pos.col=2))

cols <- seq.int(1, n.grid.cols)
side2.sizes <- seq.int(from=4, by=2, length.out=length(cols)/2) + 1
side1.sizes <- rev(side2.sizes)
sizes <- c(side1.sizes, side2.sizes)

#set.seed(100)
#column.cols <- sample(rainbow(n.grid.cols, v=.75, s=.5), n.grid.cols)
#level.colors <- brewer.pal(5, 'Pastel2')
level.colors <- colorRampPalette(c('blue4', 'aquamarine'))(5)
grid.rect(gp=gpar(fill='burlywood4'))
spline.y.coords <- Map(function(col, size) {
    pushViewport(viewport(layout.pos.row=1, layout.pos.col=col))
    ys <- tail(cumsum(rep(1/size, size)) - 1/(2*size), 5)
    #grid.rect(y=unit(ys, 'npc'), height=1/size, gp=gpar(fill=level.cols, col=column.cols[col], lwd=3))
    grid.rect(y=unit(ys, 'npc'), height=1/size, gp=gpar(lwd=2, fill=level.colors, col='black'))
    popViewport()
    ys
}, cols, sizes)
spline.y.coords <- as.list(as.data.frame(do.call(rbind, spline.y.coords)))
spline.x.coords <- (cumsum(rep(1/n.grid.cols, n.grid.cols)) - 1/(2*n.grid.cols))[cols]

for (i in seq_along(spline.y.coords)) {
    y.coords <- spline.y.coords[[i]]
    #color <- level.colors[i]
    grid.xspline(c(-.02, spline.x.coords), c(y.coords[1], y.coords), gp=gpar(lwd=1, lty='dotted'))
}

vline.ys <- as.vector(rbind(rep(1.07, length(spline.x.coords)), spline.y.coords[[1]]))
vline.xs <- rep(spline.x.coords, each=2)
vline.ids <- rep(seq_along(spline.x.coords), each=2)
grid.polyline(vline.xs, vline.ys, id=vline.ids, gp=gpar(lty='dashed'))

popViewport()
pushViewport(viewport(layout.pos.row=2, layout.pos.col=1))

left.ys <- cumsum(rep(1/5, 5)) - (1/(2 * 5))
left.xs <- rep(.8, 5)

farleft.xs <- left.xs - .05
farleft.ys <- left.ys

right.ys <- as.data.frame(do.call(rbind, spline.y.coords))[[1]]
right.xs <- rep(.9, 5)

xs <- as.vector(rbind(farleft.xs, left.xs, right.xs))
ys <- as.vector(rbind(farleft.ys, left.ys, right.ys))

ids <- rep(1:5, each=3)

grid.polyline(xs, ys, ids, gp=gpar(lty='dashed'))

pushViewport(viewport(width=.6, height=1))
grid.polyline(x=c(0,.8, .8, .8), y=c(0,0,0,1), id=c(1,1,2,2), gp=gpar(lwd=2, lty=c('solid', 'dotted'), col=c('black', 'grey')))

grid.text('?', x=rep(.7, 5), y=farleft.ys, gp=gpar(cex=.7))
grid.text('x concentrations', x=.4, y=-.04, gp=gpar(cex=.8))

point.coords <- c(.6, .4, .2, .4, .6)-.2 
point.gp <- gpar(cex=.5, fill='red')
grid.points(x=point.coords, y=farleft.ys, gp=point.gp, pch=21)

popViewport(2)
pushViewport(viewport(layout.pos.row=1, layout.pos.col=2))

pushViewport(viewport(height=.6, width=1))
grid.polyline(x=c(-0.02, -.02, -.02, 1), y=c(1, 0, 0, 0), id=c(1,1,2,2), gp=gpar(lwd=2))

point.ys <- 1-(c(.6, .4, 0, 0, .4, .6)-.2)
point.xs <- vline.xs[seq_along(vline.xs) %% 2 == 0]
grid.rect(x=point.xs, y=point.ys/2, height=point.ys, width=1/6)
grid.points(x=point.xs, y=point.ys, gp=point.gp, pch=21)
grid.xspline(point.xs, point.ys, gp=gpar(lwd=2))


popViewport(2)

pushViewport(viewport(layout.pos.row=1, layout.pos.col=1))
pushViewport(viewport(x=.8, width=.5, angle=90))
grid.text('z concentrations', x=1, gp=gpar(cex=.8))

popViewport(2)

```

This figure shows a 2D transect of the waterbody. The top chart contains the vertically integrated concentrations. We can estimate the integral for the curve outlined by these points with Riemann sums using the fixed x dimensions for each vertical column. The chart on the left shows the horizontally integrated concentrations. Because there is no fixed height for each z-level, we have to peform a simplifying operation to arrive at z-dimensions with which we can estimate the integral. Currently, our method is equivalent to fixing the z dimension at each level as the mean of all the z-dimensions at that level. An alternative to this would be to interpolate the vertical concentrations and sample the interpolations at regular intervals.


In R, we perform this calculation with

```
Cxy.dxdy <- int.cz.dz * apply(dxdy, c(1,3), mean, na.rm=TRUE)
dint.Cxy.dxdy <- apply(Cxy.dxdy, 2, sum, na.rm=TRUE)
```
where

* `dxdy` is a 3D array of the products of dimensions of the other two axes, where the rows correspond to XY-plane index pairs, the columns correspond to the unique Z direction indexes, and the slices, the timesteps.

Finally, the we estimate the dispersion rate for the desired axis as one half of the slope of the line that best fits the weighted average centralized second moments at each timestep. 



